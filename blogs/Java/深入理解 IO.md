---
深入理解 IO
---

#### 目录

1. IO 读写的基本原理
2. 四种主要的 IO 模型

#### IO 读写的基本原理

为了避免用户进程直接操作内核，保证内核安全，操作系统将内存（虚拟内存）划分为两部分：一部分是内核空间（Kernel-Space），另一部分是用户空间（User-Space）。在 Linux 系统中，内核模块运行在内核空间，对应的进程处于内核态；用户程序运行在用户空间，对应的进程处于用户态。

操作系统的核心是内核程序，它独立于普通的应用程序，既有权限访问受保护的内核空间，也有权限访问硬件设备，而普通的应用程序并没有这样的权限。内核空间总是驻留在内存中，是为操作系统的内核保留的。应用程序不允许直接在内核空间区域进行读写，也不允许直接调用内核代码定义的函数。每个应用程序进程都有一个单独的用户空间，对应的进程处于用户态，用户态进程不能访问内核空间中的数据，也不能直接调用内核函数，因此需要将进程切换到内核态才能进行系统调用。

内核态进程可以执行任意命令，调用系统的一切资源，而用户态进程只能执行简单的运算，不能直接调用系统资源，那么问题来了：用户态进程如何执行系统调用呢？答案是：用户态进程必须通过系统调用（System Call）向内核发出指令，完成调用系统资源之类的操作。

用户程序进行 IO 的读写依赖于底层的 IO 读写，基本上会用到底层的 read 和 write 两大系统调用。

操作系统层面的 read 系统调用并不是直接从物理设备把数据读取到应用的内存中，write 系统调用也不是直接把数据写到物理设备。上层应用无论是调用 read 还是 write，都会涉及缓冲区。具体来说，上层应用通过 read 系统调用把数据从内核缓冲区复制到应用程序的进程缓冲区，通过 write 系统调用把数据从应用程序的进程缓冲区复制到操作系统的内核缓冲区。

简单来说，应用程序的 IO 操作实际上不是物理设备级别的读写，而是缓存的复制。

为什么设置那么多的缓冲区，导致读写过程那么麻烦呢？

缓冲区的目的是减少与设备之间的频繁物理交换。计算机的外部物理设备与内存和 CPU 相比，有着非常大的差距，外部设备的直接读写涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少底层系统的频繁中断所导致的时间损耗、性能损耗，出现了内核缓冲区。

操作系统会对内核缓冲区进行监控，等待缓冲区到达一定数量的时候，再进行 IO 设备的中断处理，集中执行物理设备的实际 IO 操作，通过这种机制来提升系统的性能。至于具体什么时候执行系统中断（包括读中断、写中断）则由操作系统的内核来决定，应用程序不需要关心。

上层应用使用 read 系统调用时，仅仅把数据从内核缓冲区复制到应用的缓冲区；上层应用使用 write 系统调用时，仅仅把数据从应用的缓冲区复制到内核缓冲区。

#### 四种主要的 IO 模型

常见的 IO 模型有四种：同步阻塞 IO、同步非阻塞 IO、IO 多路复用和异步 IO。

首先，解释一下阻塞与非阻塞。阻塞 IO 指的是需要内核 IO 操作彻底完成之后才返回到用户空间执行用户程序的操作指令。“阻塞” 指的是用户程序（发起 IO 请求的进程或者线程）的执行状态。可以说传统的 IO 模型都是阻塞 IO 模型，并且在 Java 中默认创建的 Socket 都属于阻塞  IO 模型。

其次，解释一下同步与异步。简单来说，可以将同步与异步看成发起 IO 请求的两种方式。同步 IO 是指用户空间（进程或者线程）是主动发起 IO 请求的一方，系统内核是被动接收方。异步 IO 则反过来，系统内核是主动发起 IO 请求的一方，用户空间是被动接收方。

#### 同步阻塞 IO

同步阻塞 IO（Blocking IO）指的是用户空间主动发起，需要等待内核 IO 操作彻底完成后才返回到用户空间的 IO 操作。在 IO 操作过程中，发起 IO 请求的用户进程处于阻塞状态。

#### 同步非阻塞 IO

非阻塞 IO（Non-Blocking IO，NIO）指的是用户空间的程序不需要等待内核 IO 操作彻底完成，可以立即返回用户空间去执行后续的指令，即发起 IO 请求的用户进程处于非阻塞状态，与此同时，内核会立即返回给用户一个 IO 状态值。

阻塞和非阻塞的区别是什么呢？阻塞是指用户进程一直等待，而不能做别的事情；非阻塞是指用户进程获得内核返回的状态值就返回自己的空间，可以去做别的事情。在 Java 中，非阻塞 IO 的 socket 被设置为 NONBLOCK 模式。

同步非阻塞 IO 也可以简称为 NIO，但是它不是 Java 中的 NIO。Java 中的 NIO（New IO）类库所归属的不是基础 IO 模型中的 NIO 模型，而是 IO 多路复用模型。

同步非阻塞 IO 指的是用户进程主动发起，不需要等待内核 IO 操作彻底完成就能立即返回用户空间的 IO 操作。在 IO 操作过程中，发起 IO 请求的用户进程处于非阻塞状态。

#### IO 多路复用

为了提高性能，操作系统引入了一种新的系统调用，专门用于查询 IO 文件描述符（含 socket 连接）的就绪状态。在 Linux 系统中，新的系统调用为 select/epoll 系统调用。通过该系统调用，一个用户进程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核就能够将文件描述符的就绪状态返回给用户进程，用户空间可以根据文件描述符的就绪状态进行相应的 IO 系统调用。

IO 多路复用属于一种经典的 Reactor 模式实现，有时也称为异步阻塞 IO，Java 中的 Selector 属于这种模型。

#### 异步 IO

异步 IO（Asynchronous IO，AIO）指的是用户空间的线程变成被动接受者，而内核空间成为主动调用者。在异步 IO 模型中，当用户线程收到通知时，数据已经被内核读取完毕并放在了用户缓冲区内，内核在 IO 完成后通知用户线程直接使用即可。

异步 IO 类似于 Java 中典型的回调模式，用户进程向内核空间注册了各种 IO 事件的回调函数，由内核去主动调用。