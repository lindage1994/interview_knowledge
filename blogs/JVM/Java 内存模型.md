---
Java 内存模型
---

#### 目录

1. 概述
2. 主内存和工作内存
3. 内存间交互操作
4. 对 volatile 变量的特殊规则
5. 原子性、可见性与有序性
6. 先行发生原则

#### 概述

Java 虚拟机规范试图定义一种 Java 内存模型（JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各个平台下都能达到一致的内存访问效果。

#### 主内存和工作内存

Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量和方法参数，因为后者是线程私有的，不会被共享，自然就不存在竞争问题。

Java 内存模型规定了所有的变量都是存储在主内存中。每条线程还有自己的工作内存，线程的工作内存中保留了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

![](https://i.loli.net/2019/02/23/5c7099a498a4a.jpg)

这里所讲的主内存、工作内存与 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上没有任何关系。

##### 内存间交互操作

Java 内存模型中定义了以下八种操作，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量来说有例外）：

- lock 锁定
- unlock 解锁
- read 读取
- load 载入
- use 使用
- assign 复制
- store 赋值
- write 写入

Java 内存模型还规定了在执行上诉八种基本操作时必须满足以下规则：

1. 不允许 read、load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起了回写但主内存不接受的情况。
2. 不允许一个线程丢弃它最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存
3. 不允许一个线程无原因的把数据从工作内存同步回主内存中
4. 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化的变量
5. 一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁
6. 如果对一个变量执行 lock 操作，那么将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值
7. 如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量
8. 对一个变量执行 unlock 操作之前，必须把此变量同步回主内存中

#### 对 volatile 变量的特殊规则

当一个变量定义为 volatile 之后，它将具备两种特性：

##### 保证此变量对所有线程的可见性

这里的可见性是指当一个线程修改了这个变量的值，新值对于其它线程来说是可以立即得知的，而普通变量的值在线程间传递均需要通过主内存来完成。

Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。

由于 volatile 变量只能保证可见性，在不符合以下两条规则的运算场景下，我们仍然要通过加锁来保证原子性。

- 运算结果并不依赖变量的当前值，或者能够确保只有单一线程修改了变量的值
- 变量不需要与其他的状态变量共同参与不变约束

##### 禁止指令重排优化

普通的变量仅仅会保证在该方法执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这一点，这也就是 Java 内存模型中描述的所谓的 “线程内表现为串行的语义”（As - if - Serial）。

volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入很多内存屏障指令来保证处理器不会发生乱序执行。

#### 原子性、可见性与有序性

##### 原子性

我们大致可以认为基本数据类型的访问读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证，Java 内存模型还提供了 lock 和 unlock 操作来满足这种需求。尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式的使用这两种操作，这两个字节码指令就对应于 Java 中的 synchronized 关键字。

##### 可见性

可见性是指当一个变量修改了共享变量的值，其他线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性，无论是普通变量还是 volatile 变量都是如此，volatile 变量的特殊规则是保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说 volatile 变量保证了多线程操作时的可见性，而普通变量则不能保证这一点。

除了 volatile 之外，Java 还有两个关键字能实现可见性，即 synchronized 和 final。同步块的可见性是由 “对变量执行 unlock 操作之前，必须先把此变量同步回主内存中” 这条规则获得，而 final 关键字的可见性是指：被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有把 this 引用传递出去，那么其他线程就能看见 final 字段的值。

##### 有序性

如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指 “线程内表现为串行的语义（As - if - Serial）”，后半句是指 “指令重排序” 现象和 “工作内存和主内存同步延迟” 现象。

Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 关键字本身就包含了禁止指令重排序的语义，而 synchronized 则是由 “一个变量在同一个时刻只允许一条线程对其进行 lock 操作” 这条规则获得的，这条规则决定了持有同一个锁的同步块只能串行的进入。

#### 先行发生原则

先行发生是指 Java 内存模型中定义的两项操作之间的偏序关系。如果是操作 A 先行发生与 B，那么操作 A 产生的影响能够被 B 观察到。下面是 Java 内存模型中天然的先行发生关系：

- 程序次序规则

  即程序的书写顺序。

- 管程锁定规则

  一个 unlock 操作先行发生与后面对同一个锁的 lock 操作。

- volatile 变量规则

  对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。

- 线程启动规则

  Thread.start 方法先行发生于此线程的每一个。