---
类加载流程和双亲委派模型
---

#### 目录

1. 概述
2. 类加载流程
3. 双亲委派模型

#### 概述

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转化解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。

在 Java 语言里面，类型的加载、链接和初始化都是程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性。比如我们可以自定义类加载器。

#### 类加载流程

类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载这七个阶段。其中验证、准备和解析这三个阶段统称为链接。

![](https://i.loli.net/2019/02/23/5c70d2f627876.jpg)

加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定。

##### 加载

在加载阶段，虚拟机需要完成以下三件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口

相对于类加载过程的其他阶段，一个非数组类的加载阶段是开发人员可控性最强的，因为加载阶段即可以使用系统类加载器，也可以自定义类加载。

对于数组类而言，情况有些不同，数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建。

加载阶段与链接阶段的部分内容（如一部分字节码文件格式校验动作）是交叉进行的，加载阶段尚未完成，链接阶段可能已经开始，但是这些夹在加载阶段之中进行的动作，仍然属于链接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

##### 验证

验证是链接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

验证是虚拟机对自身保护的一项重要工作，这个阶段大致上会完成下面四个阶段的校验工作：文件格式校验、元数据校验、字节码校验、符号引用校验。

- 文件格式校验

  验证字节流是否符合 Class 文件格式规范，保证输入的字节流能正确解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。包括验证是否以魔数 0xCAFEBABE 开头，验证主次版本是否在当前虚拟机的处理范围之内等等。

  只有通过这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的三个验证阶段完全基于方法区的存储结构进行的，不会再直接操作字节流。

- 元数据校验

  这一阶段是对字节码描述的信息进行语义分析，以保证其描述信息符合 Java 语言规范的要求。

  验证这个类是否有父类（除了 Object 类以外，所有类都应当由其父类）、验证这个类是否继承了不允许被继承的类（被 final 修饰的类）等等。

  其实这个阶段大多数情况下是不会发生问题的，因为实际开发中，这些问题都能被编译器发现。

- 字节码校验

  这个阶段是整个验证过程中最为复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法、符合逻辑的。

  这个阶段主要是对类的方法体进行校验，比如保障方法体中安全的类型转换等等。

- 符号引用校验

  符号引用校验可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。

  验证符号引用中通过字符串描述的全限定名是否能找到对应的类、富豪引用中的类、字段、方法的访问修饰符（private、protected、public、default）是否具有正确的语义等。

##### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。

需要注意的是，这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆上。其次，这里所说的变量初始值是该数据类型的零值。

```java
public static int value = 233;
```

变量 value 在准备阶段过后的初始值为 0 而不是 233，因为这时候尚未开始执行任何 Java 方法。当然，如果又加上 final 修饰，那么初始值就直接赋值了。

##### 解析

解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。

符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。

直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局有关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那么引用的目标必定已经在内存中存在了。

##### 初始化

初始化阶段是类加载过程的最后一步，这个阶段才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。

初始化阶段是执行类构造器 \<clinit>() 方法的过程。

1. \<clinit>() 方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的。编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

   ```java
   public class SuperClass {
       static {
           value = 1;  //可以赋值
           System.out.println(value);  //编译器提示非法向前引用
       }
       private static int value = 233;
   }
   ```

2. \<clinit>() 方法与类的构造函数（或者说实例构造器\<init>()方法）不同，它不需要显式的调用父构造器，虚拟机会保证在子类的 \<clinit>() 方法执行之前，父类的 \<clinit>() 方法已经执行完毕。因此，第一个被执行的 \<clinit>() 方法的类肯定是 java.lang.Object。

3. 由于父类的 \<clinit>() 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。

   ```java
   public class SuperClass {
       public static int value = 233;
       static {
           value = 1;
       }
   }
   public class SubClass extends SuperClass {
       public static int value=SuperClass.value;
       /**
        * 输出 1
        */
       public static void main(String[] args) {
           System.out.println(value);
       }
   }
   ```

4. \<clinit>() 方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 \<clinit>() 方法。

5. 接口中不能有静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 \<clinit>() 方法。但接口与类不同的是，执行接口的 \<clinit>() 方法不需要先执行父接口的 \<clinit>() 方法，只有当父接口中定义的变量使用时，父接口才会初始化。

6. 虚拟机会保证一个类的 \<clinit>() 方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 \<clinit>() 方法，其它线程都需要阻塞等待，直到活动线程执行 \<clinit>() 方法完毕。

虚拟机严格规定有且只有五种情况必须立即对类进行初始化：

1. 遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类没有进行初始化，则需要先初始化。生成这四条指令的最常见的场景是：使用 new 关键字实例化对象的时候、调用类的静态属性或方法等
2. 使用反射
3. 当初始化一个类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
4. 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机需要先初始化这个主类
5. 当使用 JDK1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化

这五种场景中的行为，称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。

被动引用例一：

```java
public class SuperClass {
    static {
        System.out.println("SuperClass init !");
    }

    public static int value = 233;
}

public class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init !");
    }
}

public class ClassLoaderTest {
    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }
}
	//输出：
    /**
     * SuperClass init !
     * 233
     */
```

对于静态字段，只有直接定义了这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

被动引用例二：

```java
public class ClassLoaderTest {
    public static void main(String[] args) {
        SuperClass[] superClasses = new SuperClass[10];
    }
}
```

通过数组定义来引用类，不会触发此类的初始化。

被动引用例三：

```java
public class SuperClass {
    static {
        System.out.println("SuperClass init !");
    }

    public static int value = 233;
    public static final String TEST = "TEST";
}

public class ClassLoaderTest {
    public static void main(String[] args) {
        System.out.println(SuperClass.TEST);
    }
}
	//输出：
    /**
     * TEST
     */
```

常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块来输出初始化信息的，而接口中不能使用 static{} 语句块，但编译器仍然为接口生成了 \<clinit>() 类构造器，用于初始化接口中定义的成员变量。接口与类真正有区别的是前面讲诉的五种初始化场景中的第三种：一个接口在初始化时，并不要求其父接口完全都完成初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。

#### 双亲委派模型

##### 类加载器

虚拟机设计团队把类加载阶段中的 “通过一个类的全限定名来获取描述此类的二进制字节流” 这个动作放到了 Java 虚拟机的外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码模板称为 “类加载器”。

##### 类与类加载器

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性。

##### 双亲委派模型

从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分；另外一种就是其他类加载器，这些类加载器都是由 Java 语言实现，独立于虚拟机外部，并且都继承自抽象类 java.lang.ClassLoader。

当然，类加载器还可以划分的更细致一点：

- 启动类加载器
- 扩展类加载器
- 应用程序类加载器

如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

![](https://i.loli.net/2019/02/23/5c71425e71abe.png)

以上就是类加载器之间的层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的关系一般不会以继承的关系来实现，而是使用组合来复用父加载器的代码。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求都应该传到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都会委托给处于模型顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并存放在程序的 ClassPath 中，那么系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将变得混乱。

双亲委派模型对于保证 Java 程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在 java.lang.ClassLoader 的 loadClass 方法中：

先检查是否已经被加载过了，如果没有加载则调用父加载器的 loadClass 方法，若父加载器为空，则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出 ClassNotFoundException 异常后，在调用自己的 findClass 方法进行加载。

